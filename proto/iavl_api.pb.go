// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: iavl/iavl_api.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type HasRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *HasRequest) Reset()         { *m = HasRequest{} }
func (m *HasRequest) String() string { return proto.CompactTextString(m) }
func (*HasRequest) ProtoMessage()    {}
func (*HasRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{0}
}
func (m *HasRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HasRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HasRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HasRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasRequest.Merge(m, src)
}
func (m *HasRequest) XXX_Size() int {
	return m.Size()
}
func (m *HasRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HasRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HasRequest proto.InternalMessageInfo

func (m *HasRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type HasVersionedRequest struct {
	Version int64  `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Key     []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *HasVersionedRequest) Reset()         { *m = HasVersionedRequest{} }
func (m *HasVersionedRequest) String() string { return proto.CompactTextString(m) }
func (*HasVersionedRequest) ProtoMessage()    {}
func (*HasVersionedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{1}
}
func (m *HasVersionedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HasVersionedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HasVersionedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HasVersionedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasVersionedRequest.Merge(m, src)
}
func (m *HasVersionedRequest) XXX_Size() int {
	return m.Size()
}
func (m *HasVersionedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HasVersionedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HasVersionedRequest proto.InternalMessageInfo

func (m *HasVersionedRequest) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *HasVersionedRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type GetRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{2}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(m, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type GetByIndexRequest struct {
	Index int64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *GetByIndexRequest) Reset()         { *m = GetByIndexRequest{} }
func (m *GetByIndexRequest) String() string { return proto.CompactTextString(m) }
func (*GetByIndexRequest) ProtoMessage()    {}
func (*GetByIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{3}
}
func (m *GetByIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetByIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByIndexRequest.Merge(m, src)
}
func (m *GetByIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetByIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetByIndexRequest proto.InternalMessageInfo

func (m *GetByIndexRequest) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type GetVersionedRequest struct {
	Version int64  `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Key     []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *GetVersionedRequest) Reset()         { *m = GetVersionedRequest{} }
func (m *GetVersionedRequest) String() string { return proto.CompactTextString(m) }
func (*GetVersionedRequest) ProtoMessage()    {}
func (*GetVersionedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{4}
}
func (m *GetVersionedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVersionedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVersionedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVersionedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVersionedRequest.Merge(m, src)
}
func (m *GetVersionedRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetVersionedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVersionedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetVersionedRequest proto.InternalMessageInfo

func (m *GetVersionedRequest) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GetVersionedRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type SetRequest struct {
	Key   []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SetRequest) Reset()         { *m = SetRequest{} }
func (m *SetRequest) String() string { return proto.CompactTextString(m) }
func (*SetRequest) ProtoMessage()    {}
func (*SetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{5}
}
func (m *SetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRequest.Merge(m, src)
}
func (m *SetRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetRequest proto.InternalMessageInfo

func (m *SetRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SetRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type RemoveRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *RemoveRequest) Reset()         { *m = RemoveRequest{} }
func (m *RemoveRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveRequest) ProtoMessage()    {}
func (*RemoveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{6}
}
func (m *RemoveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveRequest.Merge(m, src)
}
func (m *RemoveRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveRequest proto.InternalMessageInfo

func (m *RemoveRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type DeleteVersionRequest struct {
	Version int64 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *DeleteVersionRequest) Reset()         { *m = DeleteVersionRequest{} }
func (m *DeleteVersionRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteVersionRequest) ProtoMessage()    {}
func (*DeleteVersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{7}
}
func (m *DeleteVersionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteVersionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteVersionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteVersionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteVersionRequest.Merge(m, src)
}
func (m *DeleteVersionRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteVersionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteVersionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteVersionRequest proto.InternalMessageInfo

func (m *DeleteVersionRequest) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type VersionExistsRequest struct {
	Version int64 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *VersionExistsRequest) Reset()         { *m = VersionExistsRequest{} }
func (m *VersionExistsRequest) String() string { return proto.CompactTextString(m) }
func (*VersionExistsRequest) ProtoMessage()    {}
func (*VersionExistsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{8}
}
func (m *VersionExistsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionExistsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionExistsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionExistsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionExistsRequest.Merge(m, src)
}
func (m *VersionExistsRequest) XXX_Size() int {
	return m.Size()
}
func (m *VersionExistsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionExistsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VersionExistsRequest proto.InternalMessageInfo

func (m *VersionExistsRequest) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type VerifyRequest struct {
	RootHash []byte      `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	Proof    *RangeProof `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *VerifyRequest) Reset()         { *m = VerifyRequest{} }
func (m *VerifyRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyRequest) ProtoMessage()    {}
func (*VerifyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{9}
}
func (m *VerifyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyRequest.Merge(m, src)
}
func (m *VerifyRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyRequest proto.InternalMessageInfo

func (m *VerifyRequest) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *VerifyRequest) GetProof() *RangeProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type VerifyItemRequest struct {
	RootHash []byte      `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	Proof    *RangeProof `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
	Key      []byte      `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Value    []byte      `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *VerifyItemRequest) Reset()         { *m = VerifyItemRequest{} }
func (m *VerifyItemRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyItemRequest) ProtoMessage()    {}
func (*VerifyItemRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{10}
}
func (m *VerifyItemRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyItemRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyItemRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyItemRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyItemRequest.Merge(m, src)
}
func (m *VerifyItemRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyItemRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyItemRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyItemRequest proto.InternalMessageInfo

func (m *VerifyItemRequest) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *VerifyItemRequest) GetProof() *RangeProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *VerifyItemRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *VerifyItemRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type VerifyAbsenceRequest struct {
	RootHash []byte      `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	Proof    *RangeProof `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
	Key      []byte      `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *VerifyAbsenceRequest) Reset()         { *m = VerifyAbsenceRequest{} }
func (m *VerifyAbsenceRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyAbsenceRequest) ProtoMessage()    {}
func (*VerifyAbsenceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{11}
}
func (m *VerifyAbsenceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyAbsenceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyAbsenceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyAbsenceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyAbsenceRequest.Merge(m, src)
}
func (m *VerifyAbsenceRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyAbsenceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyAbsenceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyAbsenceRequest proto.InternalMessageInfo

func (m *VerifyAbsenceRequest) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *VerifyAbsenceRequest) GetProof() *RangeProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *VerifyAbsenceRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type LoadVersionRequest struct {
	Version int64 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *LoadVersionRequest) Reset()         { *m = LoadVersionRequest{} }
func (m *LoadVersionRequest) String() string { return proto.CompactTextString(m) }
func (*LoadVersionRequest) ProtoMessage()    {}
func (*LoadVersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{12}
}
func (m *LoadVersionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadVersionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadVersionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadVersionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadVersionRequest.Merge(m, src)
}
func (m *LoadVersionRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoadVersionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadVersionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoadVersionRequest proto.InternalMessageInfo

func (m *LoadVersionRequest) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type LoadVersionForOverwritingRequest struct {
	Version int64 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *LoadVersionForOverwritingRequest) Reset()         { *m = LoadVersionForOverwritingRequest{} }
func (m *LoadVersionForOverwritingRequest) String() string { return proto.CompactTextString(m) }
func (*LoadVersionForOverwritingRequest) ProtoMessage()    {}
func (*LoadVersionForOverwritingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{13}
}
func (m *LoadVersionForOverwritingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadVersionForOverwritingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadVersionForOverwritingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadVersionForOverwritingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadVersionForOverwritingRequest.Merge(m, src)
}
func (m *LoadVersionForOverwritingRequest) XXX_Size() int {
	return m.Size()
}
func (m *LoadVersionForOverwritingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadVersionForOverwritingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoadVersionForOverwritingRequest proto.InternalMessageInfo

func (m *LoadVersionForOverwritingRequest) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type ListRequest struct {
	FromKey    []byte `protobuf:"bytes,1,opt,name=from_key,json=fromKey,proto3" json:"from_key,omitempty"`
	ToKey      []byte `protobuf:"bytes,2,opt,name=to_key,json=toKey,proto3" json:"to_key,omitempty"`
	Descending bool   `protobuf:"varint,3,opt,name=descending,proto3" json:"descending,omitempty"`
}

func (m *ListRequest) Reset()         { *m = ListRequest{} }
func (m *ListRequest) String() string { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()    {}
func (*ListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{14}
}
func (m *ListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRequest.Merge(m, src)
}
func (m *ListRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRequest proto.InternalMessageInfo

func (m *ListRequest) GetFromKey() []byte {
	if m != nil {
		return m.FromKey
	}
	return nil
}

func (m *ListRequest) GetToKey() []byte {
	if m != nil {
		return m.ToKey
	}
	return nil
}

func (m *ListRequest) GetDescending() bool {
	if m != nil {
		return m.Descending
	}
	return false
}

type HasResponse struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *HasResponse) Reset()         { *m = HasResponse{} }
func (m *HasResponse) String() string { return proto.CompactTextString(m) }
func (*HasResponse) ProtoMessage()    {}
func (*HasResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{15}
}
func (m *HasResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HasResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HasResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HasResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasResponse.Merge(m, src)
}
func (m *HasResponse) XXX_Size() int {
	return m.Size()
}
func (m *HasResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HasResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HasResponse proto.InternalMessageInfo

func (m *HasResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type GetResponse struct {
	Index    int64  `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Value    []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	NotFound bool   `protobuf:"varint,3,opt,name=not_found,json=notFound,proto3" json:"not_found,omitempty"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}
func (*GetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{16}
}
func (m *GetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse.Merge(m, src)
}
func (m *GetResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse proto.InternalMessageInfo

func (m *GetResponse) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *GetResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GetResponse) GetNotFound() bool {
	if m != nil {
		return m.NotFound
	}
	return false
}

type GetByIndexResponse struct {
	Key   []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GetByIndexResponse) Reset()         { *m = GetByIndexResponse{} }
func (m *GetByIndexResponse) String() string { return proto.CompactTextString(m) }
func (*GetByIndexResponse) ProtoMessage()    {}
func (*GetByIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{17}
}
func (m *GetByIndexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByIndexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetByIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByIndexResponse.Merge(m, src)
}
func (m *GetByIndexResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetByIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetByIndexResponse proto.InternalMessageInfo

func (m *GetByIndexResponse) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *GetByIndexResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type SetResponse struct {
	Updated bool `protobuf:"varint,1,opt,name=updated,proto3" json:"updated,omitempty"`
}

func (m *SetResponse) Reset()         { *m = SetResponse{} }
func (m *SetResponse) String() string { return proto.CompactTextString(m) }
func (*SetResponse) ProtoMessage()    {}
func (*SetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{18}
}
func (m *SetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetResponse.Merge(m, src)
}
func (m *SetResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetResponse proto.InternalMessageInfo

func (m *SetResponse) GetUpdated() bool {
	if m != nil {
		return m.Updated
	}
	return false
}

type RemoveResponse struct {
	Value   []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Removed bool   `protobuf:"varint,2,opt,name=removed,proto3" json:"removed,omitempty"`
}

func (m *RemoveResponse) Reset()         { *m = RemoveResponse{} }
func (m *RemoveResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveResponse) ProtoMessage()    {}
func (*RemoveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{19}
}
func (m *RemoveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveResponse.Merge(m, src)
}
func (m *RemoveResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveResponse proto.InternalMessageInfo

func (m *RemoveResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RemoveResponse) GetRemoved() bool {
	if m != nil {
		return m.Removed
	}
	return false
}

type SaveVersionResponse struct {
	RootHash []byte `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	Version  int64  `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *SaveVersionResponse) Reset()         { *m = SaveVersionResponse{} }
func (m *SaveVersionResponse) String() string { return proto.CompactTextString(m) }
func (*SaveVersionResponse) ProtoMessage()    {}
func (*SaveVersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{20}
}
func (m *SaveVersionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SaveVersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SaveVersionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SaveVersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SaveVersionResponse.Merge(m, src)
}
func (m *SaveVersionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SaveVersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SaveVersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SaveVersionResponse proto.InternalMessageInfo

func (m *SaveVersionResponse) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *SaveVersionResponse) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type DeleteVersionResponse struct {
	RootHash []byte `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	Version  int64  `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *DeleteVersionResponse) Reset()         { *m = DeleteVersionResponse{} }
func (m *DeleteVersionResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteVersionResponse) ProtoMessage()    {}
func (*DeleteVersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{21}
}
func (m *DeleteVersionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteVersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteVersionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteVersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteVersionResponse.Merge(m, src)
}
func (m *DeleteVersionResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteVersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteVersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteVersionResponse proto.InternalMessageInfo

func (m *DeleteVersionResponse) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *DeleteVersionResponse) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type VersionResponse struct {
	Version int64 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *VersionResponse) Reset()         { *m = VersionResponse{} }
func (m *VersionResponse) String() string { return proto.CompactTextString(m) }
func (*VersionResponse) ProtoMessage()    {}
func (*VersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{22}
}
func (m *VersionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionResponse.Merge(m, src)
}
func (m *VersionResponse) XXX_Size() int {
	return m.Size()
}
func (m *VersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VersionResponse proto.InternalMessageInfo

func (m *VersionResponse) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type HashResponse struct {
	RootHash []byte `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
}

func (m *HashResponse) Reset()         { *m = HashResponse{} }
func (m *HashResponse) String() string { return proto.CompactTextString(m) }
func (*HashResponse) ProtoMessage()    {}
func (*HashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{23}
}
func (m *HashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashResponse.Merge(m, src)
}
func (m *HashResponse) XXX_Size() int {
	return m.Size()
}
func (m *HashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HashResponse proto.InternalMessageInfo

func (m *HashResponse) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

type VersionExistsResponse struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *VersionExistsResponse) Reset()         { *m = VersionExistsResponse{} }
func (m *VersionExistsResponse) String() string { return proto.CompactTextString(m) }
func (*VersionExistsResponse) ProtoMessage()    {}
func (*VersionExistsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{24}
}
func (m *VersionExistsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionExistsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionExistsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionExistsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionExistsResponse.Merge(m, src)
}
func (m *VersionExistsResponse) XXX_Size() int {
	return m.Size()
}
func (m *VersionExistsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionExistsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VersionExistsResponse proto.InternalMessageInfo

func (m *VersionExistsResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type GetWithProofResponse struct {
	Value []byte      `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Proof *RangeProof `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof,omitempty"`
}

func (m *GetWithProofResponse) Reset()         { *m = GetWithProofResponse{} }
func (m *GetWithProofResponse) String() string { return proto.CompactTextString(m) }
func (*GetWithProofResponse) ProtoMessage()    {}
func (*GetWithProofResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{25}
}
func (m *GetWithProofResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWithProofResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWithProofResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWithProofResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWithProofResponse.Merge(m, src)
}
func (m *GetWithProofResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWithProofResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWithProofResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWithProofResponse proto.InternalMessageInfo

func (m *GetWithProofResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GetWithProofResponse) GetProof() *RangeProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

type GetAvailableVersionsResponse struct {
	Versions []int64 `protobuf:"varint,1,rep,packed,name=versions,proto3" json:"versions,omitempty"`
}

func (m *GetAvailableVersionsResponse) Reset()         { *m = GetAvailableVersionsResponse{} }
func (m *GetAvailableVersionsResponse) String() string { return proto.CompactTextString(m) }
func (*GetAvailableVersionsResponse) ProtoMessage()    {}
func (*GetAvailableVersionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{26}
}
func (m *GetAvailableVersionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAvailableVersionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAvailableVersionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAvailableVersionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAvailableVersionsResponse.Merge(m, src)
}
func (m *GetAvailableVersionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAvailableVersionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAvailableVersionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAvailableVersionsResponse proto.InternalMessageInfo

func (m *GetAvailableVersionsResponse) GetVersions() []int64 {
	if m != nil {
		return m.Versions
	}
	return nil
}

type SizeResponse struct {
	Size_ int64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *SizeResponse) Reset()         { *m = SizeResponse{} }
func (m *SizeResponse) String() string { return proto.CompactTextString(m) }
func (*SizeResponse) ProtoMessage()    {}
func (*SizeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{27}
}
func (m *SizeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SizeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SizeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SizeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SizeResponse.Merge(m, src)
}
func (m *SizeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SizeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SizeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SizeResponse proto.InternalMessageInfo

func (m *SizeResponse) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type ListResponse struct {
	Key   []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}
func (*ListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cad6b4fafc2c047, []int{28}
}
func (m *ListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResponse.Merge(m, src)
}
func (m *ListResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListResponse proto.InternalMessageInfo

func (m *ListResponse) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ListResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*HasRequest)(nil), "iavl.HasRequest")
	proto.RegisterType((*HasVersionedRequest)(nil), "iavl.HasVersionedRequest")
	proto.RegisterType((*GetRequest)(nil), "iavl.GetRequest")
	proto.RegisterType((*GetByIndexRequest)(nil), "iavl.GetByIndexRequest")
	proto.RegisterType((*GetVersionedRequest)(nil), "iavl.GetVersionedRequest")
	proto.RegisterType((*SetRequest)(nil), "iavl.SetRequest")
	proto.RegisterType((*RemoveRequest)(nil), "iavl.RemoveRequest")
	proto.RegisterType((*DeleteVersionRequest)(nil), "iavl.DeleteVersionRequest")
	proto.RegisterType((*VersionExistsRequest)(nil), "iavl.VersionExistsRequest")
	proto.RegisterType((*VerifyRequest)(nil), "iavl.VerifyRequest")
	proto.RegisterType((*VerifyItemRequest)(nil), "iavl.VerifyItemRequest")
	proto.RegisterType((*VerifyAbsenceRequest)(nil), "iavl.VerifyAbsenceRequest")
	proto.RegisterType((*LoadVersionRequest)(nil), "iavl.LoadVersionRequest")
	proto.RegisterType((*LoadVersionForOverwritingRequest)(nil), "iavl.LoadVersionForOverwritingRequest")
	proto.RegisterType((*ListRequest)(nil), "iavl.ListRequest")
	proto.RegisterType((*HasResponse)(nil), "iavl.HasResponse")
	proto.RegisterType((*GetResponse)(nil), "iavl.GetResponse")
	proto.RegisterType((*GetByIndexResponse)(nil), "iavl.GetByIndexResponse")
	proto.RegisterType((*SetResponse)(nil), "iavl.SetResponse")
	proto.RegisterType((*RemoveResponse)(nil), "iavl.RemoveResponse")
	proto.RegisterType((*SaveVersionResponse)(nil), "iavl.SaveVersionResponse")
	proto.RegisterType((*DeleteVersionResponse)(nil), "iavl.DeleteVersionResponse")
	proto.RegisterType((*VersionResponse)(nil), "iavl.VersionResponse")
	proto.RegisterType((*HashResponse)(nil), "iavl.HashResponse")
	proto.RegisterType((*VersionExistsResponse)(nil), "iavl.VersionExistsResponse")
	proto.RegisterType((*GetWithProofResponse)(nil), "iavl.GetWithProofResponse")
	proto.RegisterType((*GetAvailableVersionsResponse)(nil), "iavl.GetAvailableVersionsResponse")
	proto.RegisterType((*SizeResponse)(nil), "iavl.SizeResponse")
	proto.RegisterType((*ListResponse)(nil), "iavl.ListResponse")
}

func init() { proto.RegisterFile("iavl/iavl_api.proto", fileDescriptor_5cad6b4fafc2c047) }

var fileDescriptor_5cad6b4fafc2c047 = []byte{
	// 1292 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x96, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xc0, 0xeb, 0xda, 0x89, 0xdd, 0x67, 0xa7, 0x75, 0xc6, 0x71, 0xe2, 0x38, 0xad, 0x09, 0x83,
	0x1a, 0x02, 0x91, 0xec, 0x52, 0x10, 0x87, 0xb6, 0x42, 0xa4, 0x4a, 0xeb, 0x84, 0x86, 0x3f, 0xb2,
	0x4b, 0x82, 0x10, 0x68, 0x35, 0xce, 0x8e, 0xed, 0x55, 0x9c, 0x1d, 0xb3, 0x3b, 0x76, 0xeb, 0x22,
	0x10, 0xe2, 0xc4, 0x11, 0x89, 0x2f, 0xc5, 0xb1, 0x12, 0x17, 0x8e, 0x28, 0xe1, 0x2b, 0x70, 0x47,
	0x33, 0x3b, 0xe3, 0xdd, 0xb5, 0x77, 0xed, 0x54, 0x85, 0x4b, 0xe2, 0x99, 0x9d, 0xf9, 0xbd, 0xff,
	0x6f, 0x1e, 0x14, 0x2c, 0x32, 0xec, 0xd5, 0xc4, 0x1f, 0x83, 0xf4, 0xad, 0x6a, 0xdf, 0x61, 0x9c,
	0xa1, 0x94, 0x58, 0x97, 0x6f, 0x76, 0x18, 0xeb, 0xf4, 0x68, 0x8d, 0xf4, 0xad, 0x1a, 0xb1, 0x6d,
	0xc6, 0x09, 0xb7, 0x98, 0xed, 0x7a, 0x67, 0xca, 0x1b, 0xea, 0xab, 0x5c, 0xb5, 0x06, 0xed, 0x1a,
	0x3d, 0xeb, 0xf3, 0x91, 0xfa, 0x98, 0x97, 0xd4, 0xbe, 0xc3, 0x58, 0xdb, 0xdb, 0xc1, 0x15, 0x80,
	0x7d, 0xe2, 0x36, 0xe8, 0x77, 0x03, 0xea, 0x72, 0x94, 0x87, 0xe4, 0x29, 0x1d, 0x95, 0x12, 0x9b,
	0x89, 0xed, 0x5c, 0x43, 0xfc, 0xc4, 0xbb, 0x50, 0xd8, 0x27, 0xee, 0x11, 0x75, 0x5c, 0x8b, 0xd9,
	0xd4, 0xd4, 0x07, 0x4b, 0x90, 0x1e, 0x7a, 0x7b, 0xf2, 0x70, 0xb2, 0xa1, 0x97, 0x1a, 0x71, 0xd5,
	0x47, 0x54, 0x00, 0xea, 0x94, 0xc7, 0x8b, 0x78, 0x07, 0x96, 0xeb, 0x94, 0x3f, 0x1c, 0x1d, 0xd8,
	0x26, 0x7d, 0xae, 0x8f, 0xad, 0xc0, 0x82, 0x25, 0xd6, 0x0a, 0xef, 0x2d, 0x84, 0x36, 0x75, 0xca,
	0x5f, 0x4b, 0x9b, 0x0f, 0x00, 0x9a, 0x33, 0xb4, 0x11, 0x82, 0x87, 0xa4, 0x37, 0xa0, 0xea, 0x8e,
	0xb7, 0xc0, 0x6f, 0xc2, 0x52, 0x83, 0x9e, 0xb1, 0x21, 0x8d, 0x37, 0xe3, 0x0e, 0xac, 0xec, 0xd1,
	0x1e, 0xe5, 0x54, 0xa9, 0x37, 0x57, 0x39, 0x71, 0x43, 0x9d, 0x7d, 0xf4, 0xdc, 0x72, 0xb9, 0x3b,
	0xff, 0xc6, 0x53, 0x58, 0x3a, 0xa2, 0x8e, 0xd5, 0x1e, 0xe9, 0xa3, 0x1b, 0x70, 0xcd, 0x61, 0x8c,
	0x1b, 0x5d, 0xe2, 0x76, 0x95, 0x32, 0x19, 0xb1, 0xb1, 0x4f, 0xdc, 0x2e, 0xda, 0x82, 0x05, 0x19,
	0x6a, 0x69, 0x4a, 0xf6, 0x6e, 0xbe, 0x2a, 0xa2, 0x5f, 0x6d, 0x10, 0xbb, 0x43, 0xbf, 0x10, 0xfb,
	0x0d, 0xef, 0x33, 0xfe, 0x29, 0x01, 0xcb, 0x1e, 0xf6, 0x80, 0xd3, 0xb3, 0xff, 0x12, 0xad, 0xdd,
	0x94, 0x8c, 0xf0, 0x6f, 0x2a, 0xe8, 0xdf, 0x33, 0xe9, 0x0a, 0xab, 0x3d, 0xda, 0x6d, 0xb9, 0xd4,
	0x3e, 0xa1, 0xff, 0xaf, 0x12, 0xb8, 0x0a, 0xe8, 0x90, 0x11, 0xf3, 0xd2, 0x91, 0x7a, 0x00, 0x9b,
	0x81, 0xf3, 0x8f, 0x99, 0xf3, 0xf9, 0x90, 0x3a, 0xcf, 0x1c, 0x8b, 0x5b, 0x76, 0x67, 0xfe, 0x6d,
	0x03, 0xb2, 0x87, 0x96, 0x3b, 0xce, 0xb9, 0x75, 0xc8, 0xb4, 0x1d, 0x76, 0x66, 0xf8, 0xf9, 0x93,
	0x16, 0xeb, 0x27, 0x74, 0x84, 0x8a, 0xb0, 0xc8, 0x99, 0xe1, 0x67, 0xec, 0x02, 0x67, 0x62, 0xbb,
	0x02, 0x60, 0x52, 0xf7, 0x84, 0xda, 0xa6, 0x65, 0x77, 0xa4, 0x1d, 0x99, 0x46, 0x60, 0x07, 0xdf,
	0x86, 0xac, 0x2c, 0x62, 0xb7, 0xcf, 0x6c, 0x97, 0xa2, 0x55, 0x58, 0x74, 0xa8, 0x3b, 0xe8, 0x71,
	0x89, 0xcf, 0x34, 0xd4, 0x0a, 0x1f, 0x41, 0x56, 0x16, 0xa2, 0x3a, 0x16, 0x59, 0x62, 0xd1, 0xf9,
	0x2f, 0xe2, 0x60, 0x33, 0x6e, 0xb4, 0xd9, 0xc0, 0x36, 0x95, 0x02, 0x19, 0x9b, 0xf1, 0xc7, 0x62,
	0x8d, 0x1f, 0x00, 0x0a, 0x16, 0xb0, 0xc2, 0x5f, 0xb6, 0xb4, 0xde, 0x86, 0x6c, 0x33, 0xa0, 0x55,
	0x09, 0xd2, 0x83, 0xbe, 0x49, 0x38, 0x35, 0x95, 0xf6, 0x7a, 0x89, 0x3f, 0x86, 0xeb, 0xba, 0x06,
	0x7d, 0x0b, 0x3c, 0x60, 0x22, 0xa8, 0x6b, 0x09, 0xd2, 0x8e, 0x3c, 0x67, 0x4a, 0x41, 0x99, 0x86,
	0x5e, 0xe2, 0x43, 0x28, 0x34, 0xc9, 0xd0, 0x2f, 0x50, 0x85, 0x99, 0x99, 0x64, 0x81, 0xb0, 0x5e,
	0x0d, 0x87, 0xf5, 0x33, 0x28, 0x4e, 0x14, 0xfc, 0xeb, 0xf1, 0x76, 0xe0, 0xc6, 0x24, 0x29, 0x3e,
	0xa7, 0x76, 0x20, 0x27, 0x70, 0x97, 0x92, 0x89, 0x6b, 0x50, 0x9c, 0x68, 0x34, 0x73, 0x32, 0xe5,
	0x29, 0xac, 0xd4, 0x29, 0x3f, 0xb6, 0x78, 0xd7, 0x2b, 0xa4, 0xd9, 0x0e, 0xbf, 0x6c, 0x9f, 0xb9,
	0x07, 0x37, 0xeb, 0x94, 0xef, 0x0e, 0x89, 0xd5, 0x23, 0xad, 0x9e, 0x76, 0x9b, 0xaf, 0x4d, 0x19,
	0x32, 0xca, 0x3c, 0xb7, 0x94, 0xd8, 0x4c, 0x6e, 0x27, 0x1b, 0xe3, 0x35, 0xc6, 0x90, 0x6b, 0x5a,
	0x2f, 0xfc, 0xd0, 0x23, 0x48, 0xb9, 0xd6, 0x0b, 0xaa, 0xdc, 0x22, 0x7f, 0xe3, 0x0f, 0x21, 0xe7,
	0xd5, 0xd9, 0xab, 0x65, 0xe0, 0xdd, 0x7f, 0xf2, 0x90, 0x3d, 0xd8, 0x3d, 0x3a, 0x6c, 0x52, 0x67,
	0x68, 0x9d, 0x50, 0x74, 0x1f, 0x92, 0xfb, 0xc4, 0x45, 0xca, 0x0e, 0xff, 0x79, 0x2c, 0x2f, 0x07,
	0x76, 0x3c, 0x19, 0xf8, 0xc6, 0xcf, 0x7f, 0xfc, 0xfd, 0xdb, 0xd5, 0x6b, 0x28, 0x5d, 0x1b, 0xbe,
	0x57, 0xeb, 0x12, 0x17, 0x1d, 0xcb, 0xc0, 0x8c, 0x9f, 0x28, 0xb4, 0x3e, 0xbe, 0x33, 0xf9, 0x6c,
	0x45, 0xe1, 0xd6, 0x25, 0xae, 0x80, 0x96, 0x15, 0xce, 0x18, 0x8e, 0x41, 0xf7, 0x21, 0x59, 0xa7,
	0x5c, 0x6b, 0xe5, 0xbf, 0xa8, 0x1a, 0x13, 0x28, 0xed, 0xb0, 0x56, 0x1d, 0xca, 0xd1, 0xb1, 0x7c,
	0x83, 0x55, 0x89, 0xa2, 0xb5, 0xf1, 0x8d, 0xf0, 0xab, 0x5b, 0x2e, 0x4d, 0x7f, 0x50, 0xc4, 0x55,
	0x49, 0xcc, 0xa3, 0xeb, 0x8a, 0xd8, 0x1a, 0x79, 0xed, 0xe2, 0x2b, 0xc8, 0x05, 0x33, 0x25, 0x42,
	0xbd, 0xf2, 0x78, 0x67, 0x2a, 0x9f, 0x70, 0x59, 0x52, 0x57, 0x10, 0x52, 0x54, 0xe3, 0x99, 0xc5,
	0xbb, 0x86, 0xd7, 0xb5, 0x89, 0x24, 0x4f, 0x39, 0x32, 0xe2, 0xfd, 0x8f, 0xf2, 0xc0, 0x5b, 0x92,
	0x7c, 0x0b, 0x6d, 0x08, 0xf2, 0xf7, 0xca, 0x8b, 0x3f, 0x48, 0x19, 0xbe, 0x4b, 0x7f, 0x84, 0x62,
	0x10, 0xe7, 0x5b, 0x31, 0x43, 0xd6, 0x2c, 0x73, 0xaa, 0x52, 0xe8, 0x36, 0xda, 0x9a, 0x21, 0x34,
	0x68, 0xe2, 0x47, 0x90, 0x6c, 0xfa, 0x21, 0x6d, 0x4e, 0x85, 0x34, 0xd0, 0x17, 0x31, 0x92, 0xec,
	0x1c, 0x96, 0x21, 0x75, 0x29, 0xbf, 0x97, 0x78, 0x17, 0x7d, 0x02, 0x8b, 0x5e, 0x47, 0x44, 0x05,
	0x55, 0x73, 0xc1, 0x19, 0xa5, 0xbc, 0x12, 0xde, 0x54, 0xa0, 0xa2, 0x04, 0xdd, 0xc0, 0x20, 0x40,
	0x5e, 0x67, 0x14, 0xac, 0x6f, 0x21, 0x1b, 0xe8, 0x8d, 0x68, 0xb5, 0xea, 0xcd, 0x91, 0x55, 0x3d,
	0x47, 0x56, 0x1f, 0x89, 0x39, 0xb2, 0xac, 0x3c, 0x13, 0xd1, 0x46, 0xf1, 0x86, 0x04, 0x17, 0x71,
	0x5e, 0x6a, 0x48, 0x86, 0x54, 0x1b, 0x2d, 0xf0, 0x1d, 0x58, 0x0a, 0x35, 0x4b, 0xa4, 0xfc, 0x18,
	0x35, 0x32, 0x95, 0x37, 0x22, 0xbf, 0x29, 0x31, 0xb7, 0xa4, 0x98, 0x35, 0x2c, 0x73, 0xc6, 0x94,
	0x47, 0x82, 0x82, 0x3e, 0x85, 0xf4, 0x3c, 0x1b, 0x8a, 0x1e, 0x7e, 0x12, 0x5c, 0x90, 0xe0, 0x25,
	0x94, 0x15, 0x60, 0x3d, 0x40, 0xee, 0x41, 0x4a, 0xb6, 0xed, 0x38, 0x16, 0x1a, 0xd7, 0xf0, 0xb8,
	0x17, 0xe3, 0xbc, 0x04, 0x01, 0xca, 0xa8, 0x22, 0xee, 0x22, 0x53, 0xce, 0x6d, 0x7e, 0x03, 0xd6,
	0xd6, 0x47, 0x8d, 0x7f, 0xda, 0xfa, 0xc8, 0x8e, 0x1d, 0xae, 0x18, 0xa5, 0xa4, 0x41, 0x3d, 0xe8,
	0x97, 0xb0, 0xe8, 0x0d, 0x51, 0x3a, 0x1d, 0x42, 0xb3, 0x62, 0x39, 0xc6, 0x04, 0x5c, 0x91, 0xc8,
	0x12, 0x5a, 0x95, 0x09, 0x21, 0xba, 0xb6, 0x97, 0x9e, 0x02, 0x2f, 0x60, 0x2d, 0x00, 0x7f, 0x3a,
	0xd4, 0xbd, 0x63, 0x6a, 0x5e, 0x8c, 0xc5, 0x87, 0x2a, 0x71, 0x1a, 0x6f, 0x58, 0x82, 0x7a, 0xaa,
	0x07, 0x5b, 0x35, 0xff, 0x05, 0x1c, 0x34, 0x35, 0x14, 0xc6, 0x4a, 0xda, 0x92, 0x92, 0x36, 0x51,
	0x25, 0x46, 0x12, 0x51, 0xec, 0x26, 0x64, 0x1a, 0xac, 0xd7, 0x6b, 0x91, 0x93, 0xd3, 0xd8, 0xb8,
	0xc6, 0xc9, 0x58, 0x93, 0x32, 0x96, 0x71, 0x4e, 0xca, 0x50, 0x14, 0x91, 0x77, 0x8e, 0x7c, 0x32,
	0xa7, 0x1e, 0xb7, 0x58, 0x01, 0x78, 0xdc, 0x47, 0x62, 0x1f, 0xc4, 0x70, 0x64, 0x88, 0x3e, 0xa6,
	0xb3, 0xdd, 0x45, 0x4f, 0x20, 0x25, 0xc6, 0xd2, 0x57, 0x36, 0x42, 0x65, 0x3a, 0x96, 0x09, 0xda,
	0x63, 0xc4, 0x14, 0x06, 0x7c, 0x03, 0xd9, 0xc0, 0x8c, 0x8b, 0xd4, 0x53, 0x30, 0x3d, 0x26, 0xc7,
	0x52, 0x43, 0xf5, 0x2f, 0xa8, 0xc1, 0xb2, 0xfc, 0x25, 0x01, 0xeb, 0xb1, 0x23, 0x34, 0xda, 0x9a,
	0x12, 0x16, 0x39, 0x63, 0xc7, 0x8a, 0xde, 0x91, 0xa2, 0x6f, 0xe3, 0xcd, 0x49, 0xd1, 0x46, 0x9b,
	0x39, 0x06, 0xf3, 0x41, 0x42, 0x95, 0x3d, 0x48, 0x89, 0x51, 0x62, 0x5e, 0x49, 0x07, 0xc7, 0x8d,
	0x70, 0x49, 0x8b, 0x61, 0x03, 0xed, 0x42, 0x4a, 0x0c, 0x1b, 0x48, 0xb5, 0xea, 0xc0, 0x80, 0xaf,
	0x01, 0xc1, 0x59, 0x24, 0x0c, 0xe8, 0x59, 0x2e, 0xbf, 0x93, 0x78, 0xf8, 0xc6, 0xef, 0xe7, 0x95,
	0xc4, 0xcb, 0xf3, 0x4a, 0xe2, 0xaf, 0xf3, 0x4a, 0xe2, 0xd7, 0x8b, 0xca, 0x95, 0x97, 0x17, 0x95,
	0x2b, 0x7f, 0x5e, 0x54, 0xae, 0x7c, 0xbd, 0xe0, 0xa9, 0xb4, 0x28, 0xff, 0xbd, 0xff, 0x6f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x24, 0x22, 0x00, 0x6e, 0x0d, 0x10, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// IAVLServiceClient is the client API for IAVLService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IAVLServiceClient interface {
	// Has returns a result containing a boolean on whether or not the IAVL tree
	// has a given key at a specific tree version.
	Has(ctx context.Context, in *HasRequest, opts ...grpc.CallOption) (*HasResponse, error)
	HasVersioned(ctx context.Context, in *HasVersionedRequest, opts ...grpc.CallOption) (*HasResponse, error)
	// Get returns a result containing the index and value for a given
	// key based on the current state (version) of the tree.
	// If the key does not exist, Get returns the index of the next value.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// GetByIndex returns a result containing the key and value for a given
	// index based on the current state (version) of the tree.
	GetByIndex(ctx context.Context, in *GetByIndexRequest, opts ...grpc.CallOption) (*GetByIndexResponse, error)
	// GetWithProof returns a result containing the IAVL tree version and value for
	// a given key based on the current state (version) of the tree including a
	// verifiable Merkle proof.
	GetWithProof(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetWithProofResponse, error)
	// GetVersioned returns a result containing the IAVL tree version and value
	// for a given key at a specific tree version.
	GetVersioned(ctx context.Context, in *GetVersionedRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// GetVersionedWithProof returns a result containing the IAVL tree version and
	// value for a given key at a specific tree version including a verifiable Merkle
	// proof.
	GetVersionedWithProof(ctx context.Context, in *GetVersionedRequest, opts ...grpc.CallOption) (*GetWithProofResponse, error)
	// Set returns a result after inserting a key/value pair into the IAVL tree
	// based on the current state (version) of the tree.
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error)
	// Remove returns a result after removing a key/value pair from the IAVL tree
	// based on the current state (version) of the tree.
	Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error)
	// SaveVersion saves a new IAVL tree version to the DB based on the current
	// state (version) of the tree. It returns a result containing the hash and
	// new version number.
	SaveVersion(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SaveVersionResponse, error)
	// DeleteVersion deletes an IAVL tree version from the DB. The version can then
	// no longer be accessed. It returns a result containing the version and root
	// hash of the versioned tree that was deleted.
	DeleteVersion(ctx context.Context, in *DeleteVersionRequest, opts ...grpc.CallOption) (*DeleteVersionResponse, error)
	// Version returns the IAVL tree version based on the current state.
	Version(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	// Hash returns the IAVL tree root hash based on the current state.
	Hash(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*HashResponse, error)
	// VersionExists returns a result containing a boolean on whether or not a given
	// version exists in the IAVL tree.
	VersionExists(ctx context.Context, in *VersionExistsRequest, opts ...grpc.CallOption) (*VersionExistsResponse, error)
	// Verify verifies an IAVL range proof returning an error if the proof is
	// invalid.
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// VerifyItem verifies if a given key/value pair in an IAVL range proof returning
	// an error if the proof or key is invalid.
	VerifyItem(ctx context.Context, in *VerifyItemRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// VerifyAbsence verifies the absence of a given key in an IAVL range proof
	// returning an error if the proof or key is invalid.
	VerifyAbsence(ctx context.Context, in *VerifyAbsenceRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Rollback resets the working tree to the latest saved version, discarding
	// any unsaved modifications.
	Rollback(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Returns the committed versions
	GetAvailableVersions(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetAvailableVersionsResponse, error)
	// Load the most recent version
	Load(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Load a specific version
	LoadVersion(ctx context.Context, in *LoadVersionRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Load a specific version and delete all the more recent versions
	LoadVersionForOverwriting(ctx context.Context, in *LoadVersionForOverwritingRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Get the number of leaves in the tree
	Size(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SizeResponse, error)
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (IAVLService_ListClient, error)
}

type iAVLServiceClient struct {
	cc *grpc.ClientConn
}

func NewIAVLServiceClient(cc *grpc.ClientConn) IAVLServiceClient {
	return &iAVLServiceClient{cc}
}

func (c *iAVLServiceClient) Has(ctx context.Context, in *HasRequest, opts ...grpc.CallOption) (*HasResponse, error) {
	out := new(HasResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/Has", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) HasVersioned(ctx context.Context, in *HasVersionedRequest, opts ...grpc.CallOption) (*HasResponse, error) {
	out := new(HasResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/HasVersioned", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) GetByIndex(ctx context.Context, in *GetByIndexRequest, opts ...grpc.CallOption) (*GetByIndexResponse, error) {
	out := new(GetByIndexResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/GetByIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) GetWithProof(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetWithProofResponse, error) {
	out := new(GetWithProofResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/GetWithProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) GetVersioned(ctx context.Context, in *GetVersionedRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/GetVersioned", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) GetVersionedWithProof(ctx context.Context, in *GetVersionedRequest, opts ...grpc.CallOption) (*GetWithProofResponse, error) {
	out := new(GetWithProofResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/GetVersionedWithProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error) {
	out := new(RemoveResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/Remove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) SaveVersion(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SaveVersionResponse, error) {
	out := new(SaveVersionResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/SaveVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) DeleteVersion(ctx context.Context, in *DeleteVersionRequest, opts ...grpc.CallOption) (*DeleteVersionResponse, error) {
	out := new(DeleteVersionResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/DeleteVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) Version(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) Hash(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*HashResponse, error) {
	out := new(HashResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/Hash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) VersionExists(ctx context.Context, in *VersionExistsRequest, opts ...grpc.CallOption) (*VersionExistsResponse, error) {
	out := new(VersionExistsResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/VersionExists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/Verify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) VerifyItem(ctx context.Context, in *VerifyItemRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/VerifyItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) VerifyAbsence(ctx context.Context, in *VerifyAbsenceRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/VerifyAbsence", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) Rollback(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/Rollback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) GetAvailableVersions(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetAvailableVersionsResponse, error) {
	out := new(GetAvailableVersionsResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/GetAvailableVersions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) Load(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/Load", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) LoadVersion(ctx context.Context, in *LoadVersionRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/LoadVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) LoadVersionForOverwriting(ctx context.Context, in *LoadVersionForOverwritingRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/LoadVersionForOverwriting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) Size(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*SizeResponse, error) {
	out := new(SizeResponse)
	err := c.cc.Invoke(ctx, "/iavl.IAVLService/Size", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iAVLServiceClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (IAVLService_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IAVLService_serviceDesc.Streams[0], "/iavl.IAVLService/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &iAVLServiceListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IAVLService_ListClient interface {
	Recv() (*ListResponse, error)
	grpc.ClientStream
}

type iAVLServiceListClient struct {
	grpc.ClientStream
}

func (x *iAVLServiceListClient) Recv() (*ListResponse, error) {
	m := new(ListResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IAVLServiceServer is the server API for IAVLService service.
type IAVLServiceServer interface {
	// Has returns a result containing a boolean on whether or not the IAVL tree
	// has a given key at a specific tree version.
	Has(context.Context, *HasRequest) (*HasResponse, error)
	HasVersioned(context.Context, *HasVersionedRequest) (*HasResponse, error)
	// Get returns a result containing the index and value for a given
	// key based on the current state (version) of the tree.
	// If the key does not exist, Get returns the index of the next value.
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// GetByIndex returns a result containing the key and value for a given
	// index based on the current state (version) of the tree.
	GetByIndex(context.Context, *GetByIndexRequest) (*GetByIndexResponse, error)
	// GetWithProof returns a result containing the IAVL tree version and value for
	// a given key based on the current state (version) of the tree including a
	// verifiable Merkle proof.
	GetWithProof(context.Context, *GetRequest) (*GetWithProofResponse, error)
	// GetVersioned returns a result containing the IAVL tree version and value
	// for a given key at a specific tree version.
	GetVersioned(context.Context, *GetVersionedRequest) (*GetResponse, error)
	// GetVersionedWithProof returns a result containing the IAVL tree version and
	// value for a given key at a specific tree version including a verifiable Merkle
	// proof.
	GetVersionedWithProof(context.Context, *GetVersionedRequest) (*GetWithProofResponse, error)
	// Set returns a result after inserting a key/value pair into the IAVL tree
	// based on the current state (version) of the tree.
	Set(context.Context, *SetRequest) (*SetResponse, error)
	// Remove returns a result after removing a key/value pair from the IAVL tree
	// based on the current state (version) of the tree.
	Remove(context.Context, *RemoveRequest) (*RemoveResponse, error)
	// SaveVersion saves a new IAVL tree version to the DB based on the current
	// state (version) of the tree. It returns a result containing the hash and
	// new version number.
	SaveVersion(context.Context, *empty.Empty) (*SaveVersionResponse, error)
	// DeleteVersion deletes an IAVL tree version from the DB. The version can then
	// no longer be accessed. It returns a result containing the version and root
	// hash of the versioned tree that was deleted.
	DeleteVersion(context.Context, *DeleteVersionRequest) (*DeleteVersionResponse, error)
	// Version returns the IAVL tree version based on the current state.
	Version(context.Context, *empty.Empty) (*VersionResponse, error)
	// Hash returns the IAVL tree root hash based on the current state.
	Hash(context.Context, *empty.Empty) (*HashResponse, error)
	// VersionExists returns a result containing a boolean on whether or not a given
	// version exists in the IAVL tree.
	VersionExists(context.Context, *VersionExistsRequest) (*VersionExistsResponse, error)
	// Verify verifies an IAVL range proof returning an error if the proof is
	// invalid.
	Verify(context.Context, *VerifyRequest) (*empty.Empty, error)
	// VerifyItem verifies if a given key/value pair in an IAVL range proof returning
	// an error if the proof or key is invalid.
	VerifyItem(context.Context, *VerifyItemRequest) (*empty.Empty, error)
	// VerifyAbsence verifies the absence of a given key in an IAVL range proof
	// returning an error if the proof or key is invalid.
	VerifyAbsence(context.Context, *VerifyAbsenceRequest) (*empty.Empty, error)
	// Rollback resets the working tree to the latest saved version, discarding
	// any unsaved modifications.
	Rollback(context.Context, *empty.Empty) (*empty.Empty, error)
	// Returns the committed versions
	GetAvailableVersions(context.Context, *empty.Empty) (*GetAvailableVersionsResponse, error)
	// Load the most recent version
	Load(context.Context, *empty.Empty) (*empty.Empty, error)
	// Load a specific version
	LoadVersion(context.Context, *LoadVersionRequest) (*empty.Empty, error)
	// Load a specific version and delete all the more recent versions
	LoadVersionForOverwriting(context.Context, *LoadVersionForOverwritingRequest) (*empty.Empty, error)
	// Get the number of leaves in the tree
	Size(context.Context, *empty.Empty) (*SizeResponse, error)
	List(*ListRequest, IAVLService_ListServer) error
}

// UnimplementedIAVLServiceServer can be embedded to have forward compatible implementations.
type UnimplementedIAVLServiceServer struct {
}

func (*UnimplementedIAVLServiceServer) Has(ctx context.Context, req *HasRequest) (*HasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Has not implemented")
}
func (*UnimplementedIAVLServiceServer) HasVersioned(ctx context.Context, req *HasVersionedRequest) (*HasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasVersioned not implemented")
}
func (*UnimplementedIAVLServiceServer) Get(ctx context.Context, req *GetRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedIAVLServiceServer) GetByIndex(ctx context.Context, req *GetByIndexRequest) (*GetByIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByIndex not implemented")
}
func (*UnimplementedIAVLServiceServer) GetWithProof(ctx context.Context, req *GetRequest) (*GetWithProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWithProof not implemented")
}
func (*UnimplementedIAVLServiceServer) GetVersioned(ctx context.Context, req *GetVersionedRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersioned not implemented")
}
func (*UnimplementedIAVLServiceServer) GetVersionedWithProof(ctx context.Context, req *GetVersionedRequest) (*GetWithProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersionedWithProof not implemented")
}
func (*UnimplementedIAVLServiceServer) Set(ctx context.Context, req *SetRequest) (*SetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (*UnimplementedIAVLServiceServer) Remove(ctx context.Context, req *RemoveRequest) (*RemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (*UnimplementedIAVLServiceServer) SaveVersion(ctx context.Context, req *empty.Empty) (*SaveVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveVersion not implemented")
}
func (*UnimplementedIAVLServiceServer) DeleteVersion(ctx context.Context, req *DeleteVersionRequest) (*DeleteVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVersion not implemented")
}
func (*UnimplementedIAVLServiceServer) Version(ctx context.Context, req *empty.Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (*UnimplementedIAVLServiceServer) Hash(ctx context.Context, req *empty.Empty) (*HashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hash not implemented")
}
func (*UnimplementedIAVLServiceServer) VersionExists(ctx context.Context, req *VersionExistsRequest) (*VersionExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VersionExists not implemented")
}
func (*UnimplementedIAVLServiceServer) Verify(ctx context.Context, req *VerifyRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (*UnimplementedIAVLServiceServer) VerifyItem(ctx context.Context, req *VerifyItemRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyItem not implemented")
}
func (*UnimplementedIAVLServiceServer) VerifyAbsence(ctx context.Context, req *VerifyAbsenceRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyAbsence not implemented")
}
func (*UnimplementedIAVLServiceServer) Rollback(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rollback not implemented")
}
func (*UnimplementedIAVLServiceServer) GetAvailableVersions(ctx context.Context, req *empty.Empty) (*GetAvailableVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableVersions not implemented")
}
func (*UnimplementedIAVLServiceServer) Load(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Load not implemented")
}
func (*UnimplementedIAVLServiceServer) LoadVersion(ctx context.Context, req *LoadVersionRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadVersion not implemented")
}
func (*UnimplementedIAVLServiceServer) LoadVersionForOverwriting(ctx context.Context, req *LoadVersionForOverwritingRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadVersionForOverwriting not implemented")
}
func (*UnimplementedIAVLServiceServer) Size(ctx context.Context, req *empty.Empty) (*SizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Size not implemented")
}
func (*UnimplementedIAVLServiceServer) List(req *ListRequest, srv IAVLService_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}

func RegisterIAVLServiceServer(s *grpc.Server, srv IAVLServiceServer) {
	s.RegisterService(&_IAVLService_serviceDesc, srv)
}

func _IAVLService_Has_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).Has(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/Has",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).Has(ctx, req.(*HasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_HasVersioned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasVersionedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).HasVersioned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/HasVersioned",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).HasVersioned(ctx, req.(*HasVersionedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_GetByIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).GetByIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/GetByIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).GetByIndex(ctx, req.(*GetByIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_GetWithProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).GetWithProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/GetWithProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).GetWithProof(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_GetVersioned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).GetVersioned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/GetVersioned",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).GetVersioned(ctx, req.(*GetVersionedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_GetVersionedWithProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).GetVersionedWithProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/GetVersionedWithProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).GetVersionedWithProof(ctx, req.(*GetVersionedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).Remove(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_SaveVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).SaveVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/SaveVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).SaveVersion(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_DeleteVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).DeleteVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/DeleteVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).DeleteVersion(ctx, req.(*DeleteVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).Version(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_Hash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).Hash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/Hash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).Hash(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_VersionExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).VersionExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/VersionExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).VersionExists(ctx, req.(*VersionExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/Verify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).Verify(ctx, req.(*VerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_VerifyItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).VerifyItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/VerifyItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).VerifyItem(ctx, req.(*VerifyItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_VerifyAbsence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyAbsenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).VerifyAbsence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/VerifyAbsence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).VerifyAbsence(ctx, req.(*VerifyAbsenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_Rollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).Rollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/Rollback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).Rollback(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_GetAvailableVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).GetAvailableVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/GetAvailableVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).GetAvailableVersions(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_Load_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).Load(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/Load",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).Load(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_LoadVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).LoadVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/LoadVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).LoadVersion(ctx, req.(*LoadVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_LoadVersionForOverwriting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadVersionForOverwritingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).LoadVersionForOverwriting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/LoadVersionForOverwriting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).LoadVersionForOverwriting(ctx, req.(*LoadVersionForOverwritingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_Size_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IAVLServiceServer).Size(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/iavl.IAVLService/Size",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IAVLServiceServer).Size(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IAVLService_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IAVLServiceServer).List(m, &iAVLServiceListServer{stream})
}

type IAVLService_ListServer interface {
	Send(*ListResponse) error
	grpc.ServerStream
}

type iAVLServiceListServer struct {
	grpc.ServerStream
}

func (x *iAVLServiceListServer) Send(m *ListResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _IAVLService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "iavl.IAVLService",
	HandlerType: (*IAVLServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Has",
			Handler:    _IAVLService_Has_Handler,
		},
		{
			MethodName: "HasVersioned",
			Handler:    _IAVLService_HasVersioned_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _IAVLService_Get_Handler,
		},
		{
			MethodName: "GetByIndex",
			Handler:    _IAVLService_GetByIndex_Handler,
		},
		{
			MethodName: "GetWithProof",
			Handler:    _IAVLService_GetWithProof_Handler,
		},
		{
			MethodName: "GetVersioned",
			Handler:    _IAVLService_GetVersioned_Handler,
		},
		{
			MethodName: "GetVersionedWithProof",
			Handler:    _IAVLService_GetVersionedWithProof_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _IAVLService_Set_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _IAVLService_Remove_Handler,
		},
		{
			MethodName: "SaveVersion",
			Handler:    _IAVLService_SaveVersion_Handler,
		},
		{
			MethodName: "DeleteVersion",
			Handler:    _IAVLService_DeleteVersion_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _IAVLService_Version_Handler,
		},
		{
			MethodName: "Hash",
			Handler:    _IAVLService_Hash_Handler,
		},
		{
			MethodName: "VersionExists",
			Handler:    _IAVLService_VersionExists_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _IAVLService_Verify_Handler,
		},
		{
			MethodName: "VerifyItem",
			Handler:    _IAVLService_VerifyItem_Handler,
		},
		{
			MethodName: "VerifyAbsence",
			Handler:    _IAVLService_VerifyAbsence_Handler,
		},
		{
			MethodName: "Rollback",
			Handler:    _IAVLService_Rollback_Handler,
		},
		{
			MethodName: "GetAvailableVersions",
			Handler:    _IAVLService_GetAvailableVersions_Handler,
		},
		{
			MethodName: "Load",
			Handler:    _IAVLService_Load_Handler,
		},
		{
			MethodName: "LoadVersion",
			Handler:    _IAVLService_LoadVersion_Handler,
		},
		{
			MethodName: "LoadVersionForOverwriting",
			Handler:    _IAVLService_LoadVersionForOverwriting_Handler,
		},
		{
			MethodName: "Size",
			Handler:    _IAVLService_Size_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _IAVLService_List_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "iavl/iavl_api.proto",
}

func (m *HasRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HasRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HasVersionedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasVersionedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HasVersionedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetByIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetByIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetVersionedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVersionedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetVersionedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteVersionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVersionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteVersionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VersionExistsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionExistsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionExistsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VerifyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIavlApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RootHash) > 0 {
		i -= len(m.RootHash)
		copy(dAtA[i:], m.RootHash)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.RootHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyItemRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyItemRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyItemRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIavlApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RootHash) > 0 {
		i -= len(m.RootHash)
		copy(dAtA[i:], m.RootHash)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.RootHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyAbsenceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyAbsenceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyAbsenceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIavlApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RootHash) > 0 {
		i -= len(m.RootHash)
		copy(dAtA[i:], m.RootHash)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.RootHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoadVersionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadVersionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadVersionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoadVersionForOverwritingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadVersionForOverwritingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadVersionForOverwritingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Descending {
		i--
		if m.Descending {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ToKey) > 0 {
		i -= len(m.ToKey)
		copy(dAtA[i:], m.ToKey)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.ToKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromKey) > 0 {
		i -= len(m.FromKey)
		copy(dAtA[i:], m.FromKey)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.FromKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HasResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HasResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NotFound {
		i--
		if m.NotFound {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetByIndexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByIndexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetByIndexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Updated {
		i--
		if m.Updated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Removed {
		i--
		if m.Removed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SaveVersionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SaveVersionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SaveVersionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RootHash) > 0 {
		i -= len(m.RootHash)
		copy(dAtA[i:], m.RootHash)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.RootHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteVersionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVersionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteVersionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RootHash) > 0 {
		i -= len(m.RootHash)
		copy(dAtA[i:], m.RootHash)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.RootHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VersionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RootHash) > 0 {
		i -= len(m.RootHash)
		copy(dAtA[i:], m.RootHash)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.RootHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VersionExistsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionExistsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionExistsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetWithProofResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWithProofResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWithProofResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIavlApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAvailableVersionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAvailableVersionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAvailableVersionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Versions) > 0 {
		dAtA6 := make([]byte, len(m.Versions)*10)
		var j5 int
		for _, num1 := range m.Versions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintIavlApi(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SizeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SizeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SizeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintIavlApi(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintIavlApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintIavlApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovIavlApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HasRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *HasVersionedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovIavlApi(uint64(m.Version))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *GetByIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovIavlApi(uint64(m.Index))
	}
	return n
}

func (m *GetVersionedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovIavlApi(uint64(m.Version))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *SetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *RemoveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *DeleteVersionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovIavlApi(uint64(m.Version))
	}
	return n
}

func (m *VersionExistsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovIavlApi(uint64(m.Version))
	}
	return n
}

func (m *VerifyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RootHash)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *VerifyItemRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RootHash)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovIavlApi(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *VerifyAbsenceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RootHash)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovIavlApi(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *LoadVersionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovIavlApi(uint64(m.Version))
	}
	return n
}

func (m *LoadVersionForOverwritingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovIavlApi(uint64(m.Version))
	}
	return n
}

func (m *ListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromKey)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	l = len(m.ToKey)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	if m.Descending {
		n += 2
	}
	return n
}

func (m *HasResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *GetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovIavlApi(uint64(m.Index))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	if m.NotFound {
		n += 2
	}
	return n
}

func (m *GetByIndexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *SetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Updated {
		n += 2
	}
	return n
}

func (m *RemoveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	if m.Removed {
		n += 2
	}
	return n
}

func (m *SaveVersionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RootHash)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovIavlApi(uint64(m.Version))
	}
	return n
}

func (m *DeleteVersionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RootHash)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovIavlApi(uint64(m.Version))
	}
	return n
}

func (m *VersionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovIavlApi(uint64(m.Version))
	}
	return n
}

func (m *HashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RootHash)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *VersionExistsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *GetWithProofResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func (m *GetAvailableVersionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Versions) > 0 {
		l = 0
		for _, e := range m.Versions {
			l += sovIavlApi(uint64(e))
		}
		n += 1 + sovIavlApi(uint64(l)) + l
	}
	return n
}

func (m *SizeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovIavlApi(uint64(m.Size_))
	}
	return n
}

func (m *ListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovIavlApi(uint64(l))
	}
	return n
}

func sovIavlApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIavlApi(x uint64) (n int) {
	return sovIavlApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HasRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasVersionedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasVersionedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasVersionedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVersionedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVersionedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVersionedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVersionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVersionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVersionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionExistsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionExistsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionExistsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append(m.RootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RootHash == nil {
				m.RootHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &RangeProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyItemRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyItemRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyItemRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append(m.RootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RootHash == nil {
				m.RootHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &RangeProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyAbsenceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyAbsenceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyAbsenceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append(m.RootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RootHash == nil {
				m.RootHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &RangeProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadVersionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadVersionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadVersionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadVersionForOverwritingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadVersionForOverwritingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadVersionForOverwritingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromKey = append(m.FromKey[:0], dAtA[iNdEx:postIndex]...)
			if m.FromKey == nil {
				m.FromKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToKey = append(m.ToKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ToKey == nil {
				m.ToKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descending", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Descending = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotFound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotFound = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByIndexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByIndexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Updated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Removed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SaveVersionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SaveVersionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SaveVersionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append(m.RootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RootHash == nil {
				m.RootHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVersionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVersionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVersionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append(m.RootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RootHash == nil {
				m.RootHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append(m.RootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RootHash == nil {
				m.RootHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionExistsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionExistsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionExistsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWithProofResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWithProofResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWithProofResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &RangeProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAvailableVersionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAvailableVersionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAvailableVersionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIavlApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Versions = append(m.Versions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowIavlApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthIavlApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthIavlApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Versions) == 0 {
					m.Versions = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowIavlApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Versions = append(m.Versions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SizeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SizeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SizeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIavlApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIavlApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIavlApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthIavlApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIavlApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIavlApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIavlApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIavlApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIavlApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIavlApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIavlApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIavlApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIavlApi = fmt.Errorf("proto: unexpected end of group")
)
